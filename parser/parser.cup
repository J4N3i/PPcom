package parser;

import java_cup.runtime.*;
import ast.*;
import java.util.*;

/* Parser code */
parser code {:
    // Custom error formatting
    private String formatError(int line, String message) {
        return String.format("Line %d: %s", line, message);
    }

    public void syntax_error(Symbol cur_token) {
        String errorMsg;
        
        if (cur_token.value != null) {
            Symbol prev = previous_token();
            String prevValue = prev != null ? String.valueOf(prev.value) : "";
            
            // Specific error cases based on context
            if (cur_token.value.toString().matches("^\\d.*") && prevValue.equals("let")) {
                errorMsg = formatError(cur_token.left, "expected IDENT after 'let'");
            }
            else if (cur_token.value instanceof Integer && 
                     (prevValue.equals("body") || prevValue.equals("="))) {
                errorMsg = formatError(cur_token.left, "expected STRING after 'body ='");
            }
            else if (cur_token.value instanceof String && 
                     prevValue.equals("status")) {
                errorMsg = formatError(cur_token.left, "expected NUMBER for status");
            }
            else if (!String.valueOf(cur_token.value).endsWith(";") && 
                     (prevValue.equals("200") || prevValue.matches(".*\".*"))) {
                errorMsg = formatError(cur_token.left, "expected ';' after request");
            }
            else {
                errorMsg = formatError(cur_token.left, 
                    String.format("unexpected token: %s", cur_token.value));
            }
        } else {
            errorMsg = formatError(cur_token.left, "unexpected end of input");
        }
        
        report_error(errorMsg, null);
    }

    public void report_error(String message, Object info) {
        // Print error in a more visible format
        System.err.println("\nERROR: " + message);
    }
    
    public void unrecovered_syntax_error(Symbol cur_token) {
        System.err.println("\nFATAL ERROR: Unrecoverable syntax error at line " + 
                          cur_token.left);
        System.exit(1);
    }

    private Symbol previous_token() {
        try {
            return ((Symbol)stack.peek());
        } catch (Exception e) {
            return null;
        }
    }
:};

/* Terminals (tokens) */
terminal CONFIG, BASE_URL, HEADER, LET, TEST;
terminal GET, POST, PUT, DELETE;
terminal EXPECT, STATUS, BODY, CONTAINS;
terminal EQUALS, SEMICOLON, LBRACE, RBRACE;
terminal String IDENTIFIER, STRING, MULTILINE_STRING;
terminal Integer NUMBER;

/* Non-terminals */
non terminal ProgramNode program;
non terminal ConfigNode config_opt, config_block;
non terminal List config_items;
non terminal List variables;
non terminal VariableNode variable;
non terminal Object value;
non terminal List tests;
non terminal TestNode test_block;
non terminal List test_statements;
non terminal Object test_statement;
non terminal RequestNode request;
non terminal List request_block_opt, request_items;
non terminal Object request_item;
non terminal HeaderNode header_decl;
non terminal AssertionNode assertion;

/* Precedence (not needed for this grammar) */

/* Grammar Rules */
start with program;

/* Program: config? variables* tests+ */
program ::= 
    config_opt:c variables:v tests:t
    {: 
        ProgramNode prog = new ProgramNode();
        if (c != null) {
            prog.setConfig(c);
        }
        for (Object var : v) {
            prog.addVariable((VariableNode) var);
        }
        for (Object test : t) {
            prog.addTest((TestNode) test);
        }
        RESULT = prog;
    :}
    ;

/* Config block (optional) */
config_opt ::= 
    config_block:c          {: RESULT = c; :}
    | /* empty */           {: RESULT = null; :}
    ;

config_block ::= 
    CONFIG LBRACE config_items:items RBRACE
    {:
        ConfigNode config = new ConfigNode();
        for (Object item : items) {
            if (item instanceof String) {
                config.setBaseUrl((String) item);
            } else if (item instanceof HeaderNode) {
                config.addHeader((HeaderNode) item);
            }
        }
        RESULT = config;
    :}
    ;

config_items ::=
    config_items:list BASE_URL EQUALS STRING:url SEMICOLON
    {:
        list.add(url);
        RESULT = list;
    :}
    | config_items:list header_decl:h
    {:
        list.add(h);
        RESULT = list;
    :}
    | /* empty */
    {:
        RESULT = new ArrayList();
    :}
    ;

header_decl ::=
    HEADER STRING:key EQUALS STRING:val SEMICOLON
    {:
        RESULT = new HeaderNode(key, val);
    :}
    ;

/* Variables: let name = value; */
variables ::=
    variables:list variable:v
    {:
        list.add(v);
        RESULT = list;
    :}
    | /* empty */
    {:
        RESULT = new ArrayList();
    :}
    ;

variable ::=
    LET IDENTIFIER:name EQUALS value:val SEMICOLON
    {:
        // Check if identifier starts with a digit
        if (name.matches("^\\d.*")) {
            report_error("Identifier cannot start with a digit: " + name, null);
        }
        RESULT = new VariableNode(name, val);
    :}
    ;

value ::=
    STRING:s        {: RESULT = s; :}
    | NUMBER:n      {: RESULT = n; :}
    ;

/* Tests: test Name { ... } */
tests ::=
    tests:list test_block:t
    {:
        list.add(t);
        RESULT = list;
    :}
    | test_block:t
    {:
        List list = new ArrayList();
        list.add(t);
        RESULT = list;
    :}
    ;

test_block ::=
    TEST IDENTIFIER:name LBRACE test_statements:stmts RBRACE
    {:
        TestNode test = new TestNode(name);
        for (Object stmt : stmts) {
            if (stmt instanceof RequestNode) {
                test.addRequest((RequestNode) stmt);
            } else if (stmt instanceof AssertionNode) {
                test.addAssertion((AssertionNode) stmt);
            }
        }
        RESULT = test;
    :}
    ;

test_statements ::=
    test_statements:list test_statement:stmt
    {:
        list.add(stmt);
        RESULT = list;
    :}
    | test_statement:stmt
    {:
        List list = new ArrayList();
        list.add(stmt);
        RESULT = list;
    :}
    ;

test_statement ::=
    request:r           {: RESULT = r; :}
    | assertion:a       {: RESULT = a; :}
    ;

/* HTTP Requests */
request ::=
    GET STRING:path SEMICOLON
    {:
        RESULT = new RequestNode(RequestNode.HttpMethod.GET, path);
    :}
    | DELETE STRING:path SEMICOLON
    {:
        RESULT = new RequestNode(RequestNode.HttpMethod.DELETE, path);
    :}
    | POST STRING:path request_block_opt:items SEMICOLON
    {:
        RequestNode req = new RequestNode(RequestNode.HttpMethod.POST, path);
        for (Object item : items) {
            if (item instanceof HeaderNode) {
                req.addHeader((HeaderNode) item);
            } else if (item instanceof String) {
                req.setBody((String) item);
            }
        }
        RESULT = req;
    :}
    | PUT STRING:path request_block_opt:items SEMICOLON
    {:
        RequestNode req = new RequestNode(RequestNode.HttpMethod.PUT, path);
        for (Object item : items) {
            if (item instanceof HeaderNode) {
                req.addHeader((HeaderNode) item);
            } else if (item instanceof String) {
                req.setBody((String) item);
            }
        }
        RESULT = req;
    :}
    ;

request_block_opt ::=
    LBRACE request_items:items RBRACE      {: RESULT = items; :}
    | /* empty */                          {: RESULT = new ArrayList(); :}
    ;

request_items ::=
    request_items:list request_item:item
    {:
        list.add(item);
        RESULT = list;
    :}
    | /* empty */
    {:
        RESULT = new ArrayList();
    :}
    ;

request_item ::=
    header_decl:h       {: RESULT = h; :}
    | BODY EQUALS STRING:s SEMICOLON    {: RESULT = s; :}
    | BODY EQUALS MULTILINE_STRING:s SEMICOLON    {: RESULT = s; :}
    | BODY EQUALS NUMBER:n 
    {:
        parser.report_error(formatError(nleft, "expected STRING after 'body ='"), null);
        RESULT = "";
    :}
    ;

/* Assertions */
assertion ::=
    EXPECT STATUS EQUALS NUMBER:code SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.STATUS, code);
    :}
    | EXPECT STATUS EQUALS STRING:s
    {:
        parser.report_error(formatError(sleft, "expected NUMBER for status"), null);
        RESULT = new AssertionNode(AssertionNode.AssertionType.STATUS, 0);
    :}
    | EXPECT HEADER STRING:key EQUALS STRING:val SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.HEADER_EQUALS, key, val);
    :}
    | EXPECT HEADER STRING:key CONTAINS STRING:val SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.HEADER_CONTAINS, key, val);
    :}
    | EXPECT BODY CONTAINS STRING:val SEMICOLON
    {:
        RESULT = new AssertionNode(AssertionNode.AssertionType.BODY_CONTAINS, val);
    :}
    ;